/*
Glean Client API

# Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package glean_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// ImagesAPIService ImagesAPI service
type ImagesAPIService service

type ApiImagesRequest struct {
	ctx context.Context
	ApiService *ImagesAPIService
	xScioActas *string
	key *string
	type_ *ImageType
	id *string
	ds *string
	cid *string
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiImagesRequest) XScioActas(xScioActas string) ApiImagesRequest {
	r.xScioActas = &xScioActas
	return r
}

// Primary key for the image being asked. The key is returned by the API when an image is uploaded. If key is used, other parameters should not be used.
func (r ApiImagesRequest) Key(key string) ApiImagesRequest {
	r.key = &key
	return r
}

// The type of image requested. Supported values are listed in ImageMetadata.type enum.
func (r ApiImagesRequest) Type_(type_ ImageType) ApiImagesRequest {
	r.type_ = &type_
	return r
}

// ID, if a specific entity/type is requested. The id may have different meaning for each type. for user, it is user id, for UGC, it is the id of the content, and so on.
func (r ApiImagesRequest) Id(id string) ApiImagesRequest {
	r.id = &id
	return r
}

// A specific datasource for which an image is requested for. The ds may have different meaning for each type and can also be empty for some.
func (r ApiImagesRequest) Ds(ds string) ApiImagesRequest {
	r.ds = &ds
	return r
}

// Content id to differentitate multiple images that can have the same type and datasource e.g. thumnail or image from content of UGC. It can also be empty.
func (r ApiImagesRequest) Cid(cid string) ApiImagesRequest {
	r.cid = &cid
	return r
}

func (r ApiImagesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ImagesExecute(r)
}

/*
Images Get image

Serves images of various types (profile pic, background, UGC thumnail/content, etc).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImagesRequest
*/
func (a *ImagesAPIService) Images(ctx context.Context) ApiImagesRequest {
	return ApiImagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImagesAPIService) ImagesExecute(r ApiImagesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.Images")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "form", "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadimageRequest struct {
	ctx context.Context
	ApiService *ImagesAPIService
	payload *os.File
	xScioActas *string
	type_ *ImageType
	id *string
	ds *string
	cid *string
}

// Content and metadata for the image. Content is in the POST body, metadata is in the URL.
func (r ApiUploadimageRequest) Payload(payload *os.File) ApiUploadimageRequest {
	r.payload = payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiUploadimageRequest) XScioActas(xScioActas string) ApiUploadimageRequest {
	r.xScioActas = &xScioActas
	return r
}

// The type of image requested. Supported values are listed in ImageMetadata.type enum.
func (r ApiUploadimageRequest) Type_(type_ ImageType) ApiUploadimageRequest {
	r.type_ = &type_
	return r
}

// ID, if a specific entity/type is requested. The id may have different meaning for each type. For USER, it is user id For UGC, it is the id of the content For ICON, the doctype.
func (r ApiUploadimageRequest) Id(id string) ApiUploadimageRequest {
	r.id = &id
	return r
}

// A specific datasource for which an image is requested for. The ds may have different meaning for each type and can also be empty for some. For USER, it is empty or datasource the icon is asked for. For UGC, it is the UGC datasource. For ICON, it is datasource instance the icon is asked for.
func (r ApiUploadimageRequest) Ds(ds string) ApiUploadimageRequest {
	r.ds = &ds
	return r
}

// Content id to differentitate multiple images that can have the same type and datasource e.g. thumnail or image from content of UGC. It can also be empty.
func (r ApiUploadimageRequest) Cid(cid string) ApiUploadimageRequest {
	r.cid = &cid
	return r
}

func (r ApiUploadimageRequest) Execute() (*UploadImageResponse, *http.Response, error) {
	return r.ApiService.UploadimageExecute(r)
}

/*
Uploadimage Upload images

Upload images for various types (profile pic, background, UGC thumnail/content, etc) with additional metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadimageRequest
*/
func (a *ImagesAPIService) Uploadimage(ctx context.Context) ApiUploadimageRequest {
	return ApiUploadimageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UploadImageResponse
func (a *ImagesAPIService) UploadimageExecute(r ApiUploadimageRequest) (*UploadImageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesAPIService.Uploadimage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploadimage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "form", "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
