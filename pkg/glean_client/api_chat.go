/*
Glean Client API

# Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package glean_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ChatAPIService ChatAPI service
type ChatAPIService service

type ApiAskRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	xScioActas *string
	payload *AskRequest
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiAskRequest) XScioActas(xScioActas string) ApiAskRequest {
	r.xScioActas = &xScioActas
	return r
}

// Ask request
func (r ApiAskRequest) Payload(payload AskRequest) ApiAskRequest {
	r.payload = &payload
	return r
}

func (r ApiAskRequest) Execute() (*AskResponse, *http.Response, error) {
	return r.ApiService.AskExecute(r)
}

/*
Ask Detect and answer questions

Classify a query as information seeking or not. If so, generate an AI answer and/or provide relevant documents. Useful for integrating into existing chat interfaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAskRequest
*/
func (a *ChatAPIService) Ask(ctx context.Context) ApiAskRequest {
	return ApiAskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AskResponse
func (a *ChatAPIService) AskExecute(r ApiAskRequest) (*AskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Ask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ask"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChatRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	payload *ChatRequest
	xScioActas *string
	timezoneOffset *int32
}

// Includes chat history for Glean AI to respond to.
func (r ApiChatRequest) Payload(payload ChatRequest) ApiChatRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiChatRequest) XScioActas(xScioActas string) ApiChatRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiChatRequest) TimezoneOffset(timezoneOffset int32) ApiChatRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiChatRequest) Execute() (*ChatResponse, *http.Response, error) {
	return r.ApiService.ChatExecute(r)
}

/*
Chat Chat

Have a conversation with Glean AI. Responses will be sent as data-only server-sent events as they become available line by line. Each line will be a ChatResponse. Please reach out to the Glean support team for access to this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChatRequest
*/
func (a *ChatAPIService) Chat(ctx context.Context) ApiChatRequest {
	return ApiChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatResponse
func (a *ChatAPIService) ChatExecute(r ApiChatRequest) (*ChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Chat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteallchatsRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	xScioActas *string
	timezoneOffset *int32
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeleteallchatsRequest) XScioActas(xScioActas string) ApiDeleteallchatsRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiDeleteallchatsRequest) TimezoneOffset(timezoneOffset int32) ApiDeleteallchatsRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiDeleteallchatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteallchatsExecute(r)
}

/*
Deleteallchats Deletes all saved Chats owned by a user

Deletes all saved Chats a user has had and all their contained conversational content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteallchatsRequest
*/
func (a *ChatAPIService) Deleteallchats(ctx context.Context) ApiDeleteallchatsRequest {
	return ApiDeleteallchatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ChatAPIService) DeleteallchatsExecute(r ApiDeleteallchatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Deleteallchats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteallchats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletechatsRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	payload *DeleteChatsRequest
	xScioActas *string
	timezoneOffset *int32
}

func (r ApiDeletechatsRequest) Payload(payload DeleteChatsRequest) ApiDeletechatsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeletechatsRequest) XScioActas(xScioActas string) ApiDeletechatsRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiDeletechatsRequest) TimezoneOffset(timezoneOffset int32) ApiDeletechatsRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiDeletechatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletechatsExecute(r)
}

/*
Deletechats Deletes saved Chats

Deletes saved Chats and all their contained conversational content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletechatsRequest
*/
func (a *ChatAPIService) Deletechats(ctx context.Context) ApiDeletechatsRequest {
	return ApiDeletechatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ChatAPIService) DeletechatsExecute(r ApiDeletechatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Deletechats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletechats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetchatRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	payload *GetChatRequest
	xScioActas *string
	timezoneOffset *int32
}

func (r ApiGetchatRequest) Payload(payload GetChatRequest) ApiGetchatRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiGetchatRequest) XScioActas(xScioActas string) ApiGetchatRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiGetchatRequest) TimezoneOffset(timezoneOffset int32) ApiGetchatRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiGetchatRequest) Execute() (*GetChatResponse, *http.Response, error) {
	return r.ApiService.GetchatExecute(r)
}

/*
Getchat Retrieves a Chat

Retrieves the chat history between Glean Assistant and the user for a given Chat.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetchatRequest
*/
func (a *ChatAPIService) Getchat(ctx context.Context) ApiGetchatRequest {
	return ApiGetchatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatResponse
func (a *ChatAPIService) GetchatExecute(r ApiGetchatRequest) (*GetChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Getchat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getchat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetchatapplicationRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	payload *GetChatApplicationRequest
	xScioActas *string
	timezoneOffset *int32
}

func (r ApiGetchatapplicationRequest) Payload(payload GetChatApplicationRequest) ApiGetchatapplicationRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiGetchatapplicationRequest) XScioActas(xScioActas string) ApiGetchatapplicationRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiGetchatapplicationRequest) TimezoneOffset(timezoneOffset int32) ApiGetchatapplicationRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiGetchatapplicationRequest) Execute() (*GetChatApplicationResponse, *http.Response, error) {
	return r.ApiService.GetchatapplicationExecute(r)
}

/*
Getchatapplication Gets the metadata for a custom Chat application

Gets the Chat application details for the specified application ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetchatapplicationRequest
*/
func (a *ChatAPIService) Getchatapplication(ctx context.Context) ApiGetchatapplicationRequest {
	return ApiGetchatapplicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatApplicationResponse
func (a *ChatAPIService) GetchatapplicationExecute(r ApiGetchatapplicationRequest) (*GetChatApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Getchatapplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getchatapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListchatsRequest struct {
	ctx context.Context
	ApiService *ChatAPIService
	xScioActas *string
	timezoneOffset *int32
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiListchatsRequest) XScioActas(xScioActas string) ApiListchatsRequest {
	r.xScioActas = &xScioActas
	return r
}

// The offset of the client&#39;s timezone in minutes from UTC. e.g. PDT is -420 because it&#39;s 7 hours behind UTC.
func (r ApiListchatsRequest) TimezoneOffset(timezoneOffset int32) ApiListchatsRequest {
	r.timezoneOffset = &timezoneOffset
	return r
}

func (r ApiListchatsRequest) Execute() (*ListChatsResponse, *http.Response, error) {
	return r.ApiService.ListchatsExecute(r)
}

/*
Listchats Retrieves all saved Chats

Retrieves all the saved Chats between Glean Assistant and the user. The returned Chats contain only metadata and no conversational content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListchatsRequest
*/
func (a *ChatAPIService) Listchats(ctx context.Context) ApiListchatsRequest {
	return ApiListchatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListChatsResponse
func (a *ChatAPIService) ListchatsExecute(r ApiListchatsRequest) (*ListChatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListChatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatAPIService.Listchats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listchats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timezoneOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezoneOffset", r.timezoneOffset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
