/*
Glean Client API

# Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package glean_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CollectionsAPIService CollectionsAPI service
type CollectionsAPIService service

type ApiAddcollectionitemsRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *AddCollectionItemsRequest
	xScioActas *string
}

// Data describing the add operation.
func (r ApiAddcollectionitemsRequest) Payload(payload AddCollectionItemsRequest) ApiAddcollectionitemsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiAddcollectionitemsRequest) XScioActas(xScioActas string) ApiAddcollectionitemsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiAddcollectionitemsRequest) Execute() (*AddCollectionItemsResponse, *http.Response, error) {
	return r.ApiService.AddcollectionitemsExecute(r)
}

/*
Addcollectionitems Add Collection item

Add items to a Collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddcollectionitemsRequest
*/
func (a *CollectionsAPIService) Addcollectionitems(ctx context.Context) ApiAddcollectionitemsRequest {
	return ApiAddcollectionitemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddCollectionItemsResponse
func (a *CollectionsAPIService) AddcollectionitemsExecute(r ApiAddcollectionitemsRequest) (*AddCollectionItemsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddCollectionItemsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Addcollectionitems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addcollectionitems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatecollectionRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *CreateCollectionRequest
	xScioActas *string
}

// Collection content plus any additional metadata for the request.
func (r ApiCreatecollectionRequest) Payload(payload CreateCollectionRequest) ApiCreatecollectionRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiCreatecollectionRequest) XScioActas(xScioActas string) ApiCreatecollectionRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiCreatecollectionRequest) Execute() (*CreateCollectionResponse, *http.Response, error) {
	return r.ApiService.CreatecollectionExecute(r)
}

/*
Createcollection Create Collection

Create a publicly visible (empty) Collection of documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatecollectionRequest
*/
func (a *CollectionsAPIService) Createcollection(ctx context.Context) ApiCreatecollectionRequest {
	return ApiCreatecollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCollectionResponse
func (a *CollectionsAPIService) CreatecollectionExecute(r ApiCreatecollectionRequest) (*CreateCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Createcollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createcollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CollectionError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletecollectionRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *DeleteCollectionRequest
	xScioActas *string
}

// DeleteCollection request
func (r ApiDeletecollectionRequest) Payload(payload DeleteCollectionRequest) ApiDeletecollectionRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeletecollectionRequest) XScioActas(xScioActas string) ApiDeletecollectionRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDeletecollectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletecollectionExecute(r)
}

/*
Deletecollection Delete Collection

Delete a Collection given the Collection's ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletecollectionRequest
*/
func (a *CollectionsAPIService) Deletecollection(ctx context.Context) ApiDeletecollectionRequest {
	return ApiDeletecollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CollectionsAPIService) DeletecollectionExecute(r ApiDeletecollectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Deletecollection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletecollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CollectionError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletecollectionitemRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *DeleteCollectionItemRequest
	xScioActas *string
}

// Data describing the delete operation.
func (r ApiDeletecollectionitemRequest) Payload(payload DeleteCollectionItemRequest) ApiDeletecollectionitemRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeletecollectionitemRequest) XScioActas(xScioActas string) ApiDeletecollectionitemRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDeletecollectionitemRequest) Execute() (*DeleteCollectionItemResponse, *http.Response, error) {
	return r.ApiService.DeletecollectionitemExecute(r)
}

/*
Deletecollectionitem Delete Collection item

Delete a single item from a Collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletecollectionitemRequest
*/
func (a *CollectionsAPIService) Deletecollectionitem(ctx context.Context) ApiDeletecollectionitemRequest {
	return ApiDeletecollectionitemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteCollectionItemResponse
func (a *CollectionsAPIService) DeletecollectionitemExecute(r ApiDeletecollectionitemRequest) (*DeleteCollectionItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteCollectionItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Deletecollectionitem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletecollectionitem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditcollectionRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *EditCollectionRequest
	xScioActas *string
}

// Collection content plus any additional metadata for the request.
func (r ApiEditcollectionRequest) Payload(payload EditCollectionRequest) ApiEditcollectionRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiEditcollectionRequest) XScioActas(xScioActas string) ApiEditcollectionRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiEditcollectionRequest) Execute() (*EditCollectionResponse, *http.Response, error) {
	return r.ApiService.EditcollectionExecute(r)
}

/*
Editcollection Update Collection

Update the properties of an existing Collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditcollectionRequest
*/
func (a *CollectionsAPIService) Editcollection(ctx context.Context) ApiEditcollectionRequest {
	return ApiEditcollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditCollectionResponse
func (a *CollectionsAPIService) EditcollectionExecute(r ApiEditcollectionRequest) (*EditCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Editcollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editcollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CollectionError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditcollectionitemRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *EditCollectionItemRequest
	xScioActas *string
}

// Edit Collection Items request
func (r ApiEditcollectionitemRequest) Payload(payload EditCollectionItemRequest) ApiEditcollectionitemRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiEditcollectionitemRequest) XScioActas(xScioActas string) ApiEditcollectionitemRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiEditcollectionitemRequest) Execute() (*EditCollectionItemResponse, *http.Response, error) {
	return r.ApiService.EditcollectionitemExecute(r)
}

/*
Editcollectionitem Update Collection item

Update the URL, Glean Document ID, description of an item within a Collection given its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditcollectionitemRequest
*/
func (a *CollectionsAPIService) Editcollectionitem(ctx context.Context) ApiEditcollectionitemRequest {
	return ApiEditcollectionitemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditCollectionItemResponse
func (a *CollectionsAPIService) EditcollectionitemExecute(r ApiEditcollectionitemRequest) (*EditCollectionItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditCollectionItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Editcollectionitem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editcollectionitem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditdocumentcollectionsRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *EditDocumentCollectionsRequest
	xScioActas *string
}

// Data describing the edit operation.
func (r ApiEditdocumentcollectionsRequest) Payload(payload EditDocumentCollectionsRequest) ApiEditdocumentcollectionsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiEditdocumentcollectionsRequest) XScioActas(xScioActas string) ApiEditdocumentcollectionsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiEditdocumentcollectionsRequest) Execute() (*EditDocumentCollectionsResponse, *http.Response, error) {
	return r.ApiService.EditdocumentcollectionsExecute(r)
}

/*
Editdocumentcollections Update document Collections

Update the Collections that a document belongs to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditdocumentcollectionsRequest
*/
func (a *CollectionsAPIService) Editdocumentcollections(ctx context.Context) ApiEditdocumentcollectionsRequest {
	return ApiEditdocumentcollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditDocumentCollectionsResponse
func (a *CollectionsAPIService) EditdocumentcollectionsExecute(r ApiEditdocumentcollectionsRequest) (*EditDocumentCollectionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditDocumentCollectionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Editdocumentcollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editdocumentcollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetcollectionRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *GetCollectionRequest
	xScioActas *string
}

// GetCollection request
func (r ApiGetcollectionRequest) Payload(payload GetCollectionRequest) ApiGetcollectionRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiGetcollectionRequest) XScioActas(xScioActas string) ApiGetcollectionRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiGetcollectionRequest) Execute() (*GetCollectionResponse, *http.Response, error) {
	return r.ApiService.GetcollectionExecute(r)
}

/*
Getcollection Read Collection

Read the details of a Collection given its ID. Does not fetch items in this Collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetcollectionRequest
*/
func (a *CollectionsAPIService) Getcollection(ctx context.Context) ApiGetcollectionRequest {
	return ApiGetcollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCollectionResponse
func (a *CollectionsAPIService) GetcollectionExecute(r ApiGetcollectionRequest) (*GetCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Getcollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getcollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListcollectionsRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *ListCollectionsRequest
	xScioActas *string
}

// ListCollections request
func (r ApiListcollectionsRequest) Payload(payload ListCollectionsRequest) ApiListcollectionsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiListcollectionsRequest) XScioActas(xScioActas string) ApiListcollectionsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiListcollectionsRequest) Execute() (*ListCollectionsResponse, *http.Response, error) {
	return r.ApiService.ListcollectionsExecute(r)
}

/*
Listcollections List Collections

List all existing Collections.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListcollectionsRequest
*/
func (a *CollectionsAPIService) Listcollections(ctx context.Context) ApiListcollectionsRequest {
	return ApiListcollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCollectionsResponse
func (a *CollectionsAPIService) ListcollectionsExecute(r ApiListcollectionsRequest) (*ListCollectionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCollectionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Listcollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listcollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMovecollectionitemRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *MoveCollectionItemRequest
	xScioActas *string
}

// MoveCollectionItems request
func (r ApiMovecollectionitemRequest) Payload(payload MoveCollectionItemRequest) ApiMovecollectionitemRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiMovecollectionitemRequest) XScioActas(xScioActas string) ApiMovecollectionitemRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiMovecollectionitemRequest) Execute() (*MoveCollectionItemResponse, *http.Response, error) {
	return r.ApiService.MovecollectionitemExecute(r)
}

/*
Movecollectionitem Move Collection item

Reorder a Collection by moving a CollectionItem below another CollectionItem.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMovecollectionitemRequest
*/
func (a *CollectionsAPIService) Movecollectionitem(ctx context.Context) ApiMovecollectionitemRequest {
	return ApiMovecollectionitemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MoveCollectionItemResponse
func (a *CollectionsAPIService) MovecollectionitemExecute(r ApiMovecollectionitemRequest) (*MoveCollectionItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MoveCollectionItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Movecollectionitem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/movecollectionitem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPincollectionRequest struct {
	ctx context.Context
	ApiService *CollectionsAPIService
	payload *PinCollectionRequest
	xScioActas *string
}

// PinCollection request
func (r ApiPincollectionRequest) Payload(payload PinCollectionRequest) ApiPincollectionRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiPincollectionRequest) XScioActas(xScioActas string) ApiPincollectionRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiPincollectionRequest) Execute() (*GetCollectionResponse, *http.Response, error) {
	return r.ApiService.PincollectionExecute(r)
}

/*
Pincollection Pin Collection

Given the Collection id and category, pins the Collection to the home page for all company users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPincollectionRequest
*/
func (a *CollectionsAPIService) Pincollection(ctx context.Context) ApiPincollectionRequest {
	return ApiPincollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCollectionResponse
func (a *CollectionsAPIService) PincollectionExecute(r ApiPincollectionRequest) (*GetCollectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCollectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.Pincollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pincollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
