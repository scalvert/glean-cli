/*
Glean Client API

# Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package glean_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AnswersAPIService AnswersAPI service
type AnswersAPIService service

type ApiCreateanswerRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *CreateAnswerRequest
	xScioActas *string
}

// CreateAnswer request
func (r ApiCreateanswerRequest) Payload(payload CreateAnswerRequest) ApiCreateanswerRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiCreateanswerRequest) XScioActas(xScioActas string) ApiCreateanswerRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiCreateanswerRequest) Execute() (*Answer, *http.Response, error) {
	return r.ApiService.CreateanswerExecute(r)
}

/*
Createanswer Create Answer

Create a user-generated Answer that contains a question and answer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateanswerRequest
*/
func (a *AnswersAPIService) Createanswer(ctx context.Context) ApiCreateanswerRequest {
	return ApiCreateanswerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Answer
func (a *AnswersAPIService) CreateanswerExecute(r ApiCreateanswerRequest) (*Answer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Answer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Createanswer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createanswer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateanswerboardRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *CreateAnswerBoardRequest
	xScioActas *string
}

// Answer Board content plus any additional metadata for the request.
func (r ApiCreateanswerboardRequest) Payload(payload CreateAnswerBoardRequest) ApiCreateanswerboardRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiCreateanswerboardRequest) XScioActas(xScioActas string) ApiCreateanswerboardRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiCreateanswerboardRequest) Execute() (*CreateAnswerBoardResponse, *http.Response, error) {
	return r.ApiService.CreateanswerboardExecute(r)
}

/*
Createanswerboard Create Answer Board

Create a board of Answers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateanswerboardRequest

Deprecated
*/
func (a *AnswersAPIService) Createanswerboard(ctx context.Context) ApiCreateanswerboardRequest {
	return ApiCreateanswerboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAnswerBoardResponse
// Deprecated
func (a *AnswersAPIService) CreateanswerboardExecute(r ApiCreateanswerboardRequest) (*CreateAnswerBoardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAnswerBoardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Createanswerboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createanswerboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteanswerRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *DeleteAnswerRequest
	xScioActas *string
}

// DeleteAnswer request
func (r ApiDeleteanswerRequest) Payload(payload DeleteAnswerRequest) ApiDeleteanswerRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeleteanswerRequest) XScioActas(xScioActas string) ApiDeleteanswerRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDeleteanswerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteanswerExecute(r)
}

/*
Deleteanswer Delete Answer

Delete an existing user-generated Answer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteanswerRequest
*/
func (a *AnswersAPIService) Deleteanswer(ctx context.Context) ApiDeleteanswerRequest {
	return ApiDeleteanswerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnswersAPIService) DeleteanswerExecute(r ApiDeleteanswerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Deleteanswer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteanswer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteanswerboardsRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *DeleteAnswerBoardsRequest
	xScioActas *string
}

// DeleteAnswerBoards request
func (r ApiDeleteanswerboardsRequest) Payload(payload DeleteAnswerBoardsRequest) ApiDeleteanswerboardsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeleteanswerboardsRequest) XScioActas(xScioActas string) ApiDeleteanswerboardsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDeleteanswerboardsRequest) Execute() (*DeleteAnswerBoardsResponse, *http.Response, error) {
	return r.ApiService.DeleteanswerboardsExecute(r)
}

/*
Deleteanswerboards Delete Answer Board

Delete an Answer Board given the Answer Board's ID. Multi-delete is not currently supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteanswerboardsRequest

Deprecated
*/
func (a *AnswersAPIService) Deleteanswerboards(ctx context.Context) ApiDeleteanswerboardsRequest {
	return ApiDeleteanswerboardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteAnswerBoardsResponse
// Deprecated
func (a *AnswersAPIService) DeleteanswerboardsExecute(r ApiDeleteanswerboardsRequest) (*DeleteAnswerBoardsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteAnswerBoardsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Deleteanswerboards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteanswerboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditanswerRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *EditAnswerRequest
	xScioActas *string
}

// EditAnswer request
func (r ApiEditanswerRequest) Payload(payload EditAnswerRequest) ApiEditanswerRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiEditanswerRequest) XScioActas(xScioActas string) ApiEditanswerRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiEditanswerRequest) Execute() (*Answer, *http.Response, error) {
	return r.ApiService.EditanswerExecute(r)
}

/*
Editanswer Update Answer

Update an existing user-generated Answer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditanswerRequest
*/
func (a *AnswersAPIService) Editanswer(ctx context.Context) ApiEditanswerRequest {
	return ApiEditanswerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Answer
func (a *AnswersAPIService) EditanswerExecute(r ApiEditanswerRequest) (*Answer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Answer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Editanswer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editanswer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditanswerboardRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *EditAnswerBoardRequest
	xScioActas *string
}

// Answer Board content plus any additional metadata for the request.
func (r ApiEditanswerboardRequest) Payload(payload EditAnswerBoardRequest) ApiEditanswerboardRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiEditanswerboardRequest) XScioActas(xScioActas string) ApiEditanswerboardRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiEditanswerboardRequest) Execute() (*EditAnswerBoardResponse, *http.Response, error) {
	return r.ApiService.EditanswerboardExecute(r)
}

/*
Editanswerboard Update Answer Board

Modifies the properties of an existing Answer Board.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditanswerboardRequest

Deprecated
*/
func (a *AnswersAPIService) Editanswerboard(ctx context.Context) ApiEditanswerboardRequest {
	return ApiEditanswerboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditAnswerBoardResponse
// Deprecated
func (a *AnswersAPIService) EditanswerboardExecute(r ApiEditanswerboardRequest) (*EditAnswerBoardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditAnswerBoardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Editanswerboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editanswerboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetanswerRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *GetAnswerRequest
	xScioActas *string
}

// GetAnswer request
func (r ApiGetanswerRequest) Payload(payload GetAnswerRequest) ApiGetanswerRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiGetanswerRequest) XScioActas(xScioActas string) ApiGetanswerRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiGetanswerRequest) Execute() (*GetAnswerResponse, *http.Response, error) {
	return r.ApiService.GetanswerExecute(r)
}

/*
Getanswer Read Answer

Read the details of a particular Answer given its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetanswerRequest
*/
func (a *AnswersAPIService) Getanswer(ctx context.Context) ApiGetanswerRequest {
	return ApiGetanswerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAnswerResponse
func (a *AnswersAPIService) GetanswerExecute(r ApiGetanswerRequest) (*GetAnswerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnswerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Getanswer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getanswer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetanswerboardRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *GetAnswerBoardRequest
	xScioActas *string
}

// GetAnswerBoard request
func (r ApiGetanswerboardRequest) Payload(payload GetAnswerBoardRequest) ApiGetanswerboardRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiGetanswerboardRequest) XScioActas(xScioActas string) ApiGetanswerboardRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiGetanswerboardRequest) Execute() (*GetAnswerBoardResponse, *http.Response, error) {
	return r.ApiService.GetanswerboardExecute(r)
}

/*
Getanswerboard Read Answer Board

Read the details of an Answer Board given its ID. Does not fetch items in this Answer Board, use /listanswers instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetanswerboardRequest

Deprecated
*/
func (a *AnswersAPIService) Getanswerboard(ctx context.Context) ApiGetanswerboardRequest {
	return ApiGetanswerboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAnswerBoardResponse
// Deprecated
func (a *AnswersAPIService) GetanswerboardExecute(r ApiGetanswerboardRequest) (*GetAnswerBoardResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnswerBoardResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Getanswerboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getanswerboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListanswerboardsRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *ListAnswerBoardsRequest
	xScioActas *string
}

// ListAnswerBoards request
func (r ApiListanswerboardsRequest) Payload(payload ListAnswerBoardsRequest) ApiListanswerboardsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiListanswerboardsRequest) XScioActas(xScioActas string) ApiListanswerboardsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiListanswerboardsRequest) Execute() (*ListAnswerBoardsResponse, *http.Response, error) {
	return r.ApiService.ListanswerboardsExecute(r)
}

/*
Listanswerboards List Answer Boards

List all existing Answer Boards

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListanswerboardsRequest

Deprecated
*/
func (a *AnswersAPIService) Listanswerboards(ctx context.Context) ApiListanswerboardsRequest {
	return ApiListanswerboardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAnswerBoardsResponse
// Deprecated
func (a *AnswersAPIService) ListanswerboardsExecute(r ApiListanswerboardsRequest) (*ListAnswerBoardsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAnswerBoardsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Listanswerboards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listanswerboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListanswersRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *ListAnswersRequest
	xScioActas *string
}

// ListAnswers request
func (r ApiListanswersRequest) Payload(payload ListAnswersRequest) ApiListanswersRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiListanswersRequest) XScioActas(xScioActas string) ApiListanswersRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiListanswersRequest) Execute() (*ListAnswersResponse, *http.Response, error) {
	return r.ApiService.ListanswersExecute(r)
}

/*
Listanswers List Answers

List Answers created by the current user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListanswersRequest
*/
func (a *AnswersAPIService) Listanswers(ctx context.Context) ApiListanswersRequest {
	return ApiListanswersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAnswersResponse
func (a *AnswersAPIService) ListanswersExecute(r ApiListanswersRequest) (*ListAnswersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAnswersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Listanswers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listanswers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewanswerRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *PreviewStructuredTextRequest
	xScioActas *string
}

// PreviewAnswer request
func (r ApiPreviewanswerRequest) Payload(payload PreviewStructuredTextRequest) ApiPreviewanswerRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiPreviewanswerRequest) XScioActas(xScioActas string) ApiPreviewanswerRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiPreviewanswerRequest) Execute() (*PreviewStructuredTextResponse, *http.Response, error) {
	return r.ApiService.PreviewanswerExecute(r)
}

/*
Previewanswer Preview Answer

Generate a preview for a user-generated Answer that contains a question and answer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewanswerRequest
*/
func (a *AnswersAPIService) Previewanswer(ctx context.Context) ApiPreviewanswerRequest {
	return ApiPreviewanswerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PreviewStructuredTextResponse
func (a *AnswersAPIService) PreviewanswerExecute(r ApiPreviewanswerRequest) (*PreviewStructuredTextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewStructuredTextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Previewanswer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/previewanswer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewanswerdraftRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *PreviewUgcRequest
	xScioActas *string
}

// preview answer request
func (r ApiPreviewanswerdraftRequest) Payload(payload PreviewUgcRequest) ApiPreviewanswerdraftRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiPreviewanswerdraftRequest) XScioActas(xScioActas string) ApiPreviewanswerdraftRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiPreviewanswerdraftRequest) Execute() (*PreviewUgcResponse, *http.Response, error) {
	return r.ApiService.PreviewanswerdraftExecute(r)
}

/*
Previewanswerdraft Preview draft Answer

Generate a preview for a user-generated answer from a draft.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewanswerdraftRequest
*/
func (a *AnswersAPIService) Previewanswerdraft(ctx context.Context) ApiPreviewanswerdraftRequest {
	return ApiPreviewanswerdraftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PreviewUgcResponse
func (a *AnswersAPIService) PreviewanswerdraftExecute(r ApiPreviewanswerdraftRequest) (*PreviewUgcResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewUgcResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Previewanswerdraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/previewanswerdraft"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateanswerlikesRequest struct {
	ctx context.Context
	ApiService *AnswersAPIService
	payload *UpdateAnswerLikesRequest
	xScioActas *string
}

// UpdateAnswerLikes request
func (r ApiUpdateanswerlikesRequest) Payload(payload UpdateAnswerLikesRequest) ApiUpdateanswerlikesRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiUpdateanswerlikesRequest) XScioActas(xScioActas string) ApiUpdateanswerlikesRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiUpdateanswerlikesRequest) Execute() (*UpdateAnswerLikesResponse, *http.Response, error) {
	return r.ApiService.UpdateanswerlikesExecute(r)
}

/*
Updateanswerlikes Update Answer likes

Update the likes for an existing user-generated Answer. Examples are liking or unliking the Answer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateanswerlikesRequest
*/
func (a *AnswersAPIService) Updateanswerlikes(ctx context.Context) ApiUpdateanswerlikesRequest {
	return ApiUpdateanswerlikesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAnswerLikesResponse
func (a *AnswersAPIService) UpdateanswerlikesExecute(r ApiUpdateanswerlikesRequest) (*UpdateAnswerLikesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAnswerLikesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnswersAPIService.Updateanswerlikes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updateanswerlikes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
