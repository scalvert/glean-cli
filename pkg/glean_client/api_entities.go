/*
Glean Client API

# Introduction These are the public APIs to enable implementing a custom client interface to the Glean system.  # Usage guidelines This API is evolving fast. Glean will provide advance notice of any planned backwards incompatible changes along with a 6-month sunset period for anything that requires developers to adopt the new versions.  # SDK Client bindings for the API can be generated for most popular languages (Python, Java, NodeJS, etc). To do so:  Download the OpenAPI specification for the API, by clicking on one of the following options: 1. [Download JSON specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.json?branch=main&download=true) 2. [Download YAML specification](https://api.redocly.com/registry/bundle/glean/Glean%20Client%20API%20SDK%20source/v1/openapi.yaml?branch=main&download=true)  Use [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator-cli) to generate bindings for your language of choice, for example: ```bash shell $ npx @openapitools/openapi-generator-cli@latest generate -i client_api.yaml -g go ```  To see available languages: ```bash shell $ npx @openapitools/openapi-generator-cli@latest list ```  Determine the host you need to connect to. This will be the URL of the backend for your Glean deployment, for example, customer-be.glean.com 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package glean_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// EntitiesAPIService EntitiesAPI service
type EntitiesAPIService service

type ApiCreateteamsRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *CreateTeamsRequest
	xScioActas *string
}

// Teams to be created
func (r ApiCreateteamsRequest) Payload(payload CreateTeamsRequest) ApiCreateteamsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiCreateteamsRequest) XScioActas(xScioActas string) ApiCreateteamsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiCreateteamsRequest) Execute() (*CreateTeamsResponse, *http.Response, error) {
	return r.ApiService.CreateteamsExecute(r)
}

/*
Createteams Create teams

Create the given teams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateteamsRequest
*/
func (a *EntitiesAPIService) Createteams(ctx context.Context) ApiCreateteamsRequest {
	return ApiCreateteamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTeamsResponse
func (a *EntitiesAPIService) CreateteamsExecute(r ApiCreateteamsRequest) (*CreateTeamsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTeamsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Createteams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createteams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomentitiesRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *CustomEntitiesRequest
	xScioActas *string
}

// Custom entities request
func (r ApiCustomentitiesRequest) Payload(payload CustomEntitiesRequest) ApiCustomentitiesRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiCustomentitiesRequest) XScioActas(xScioActas string) ApiCustomentitiesRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiCustomentitiesRequest) Execute() (*CustomEntitiesResponse, *http.Response, error) {
	return r.ApiService.CustomentitiesExecute(r)
}

/*
Customentities Read custom entities

Read the details of the custom entities with the given IDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCustomentitiesRequest
*/
func (a *EntitiesAPIService) Customentities(ctx context.Context) ApiCustomentitiesRequest {
	return ApiCustomentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomEntitiesResponse
func (a *EntitiesAPIService) CustomentitiesExecute(r ApiCustomentitiesRequest) (*CustomEntitiesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomEntitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Customentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customentities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteteamsRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *DeleteTeamsRequest
	xScioActas *string
}

// Teams to be deleted
func (r ApiDeleteteamsRequest) Payload(payload DeleteTeamsRequest) ApiDeleteteamsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDeleteteamsRequest) XScioActas(xScioActas string) ApiDeleteteamsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDeleteteamsRequest) Execute() (*DeleteTeamsResponse, *http.Response, error) {
	return r.ApiService.DeleteteamsExecute(r)
}

/*
Deleteteams Delete teams

Delete the given teams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteteamsRequest
*/
func (a *EntitiesAPIService) Deleteteams(ctx context.Context) ApiDeleteteamsRequest {
	return ApiDeleteteamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteTeamsResponse
func (a *EntitiesAPIService) DeleteteamsExecute(r ApiDeleteteamsRequest) (*DeleteTeamsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteTeamsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Deleteteams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteteams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadentitiesRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	entityType *EntitiesTypeEnum
	xScioActas *string
}

// Entity type the requested CSV should be populated with
func (r ApiDownloadentitiesRequest) EntityType(entityType EntitiesTypeEnum) ApiDownloadentitiesRequest {
	r.entityType = &entityType
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiDownloadentitiesRequest) XScioActas(xScioActas string) ApiDownloadentitiesRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiDownloadentitiesRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DownloadentitiesExecute(r)
}

/*
Downloadentities Download entities

Download a list of all entities of the specified type. Currently only supports people.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadentitiesRequest
*/
func (a *EntitiesAPIService) Downloadentities(ctx context.Context) ApiDownloadentitiesRequest {
	return ApiDownloadentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntitiesAPIService) DownloadentitiesExecute(r ApiDownloadentitiesRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Downloadentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/downloadentities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityType == nil {
		return localVarReturnValue, nil, reportError("entityType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "entityType", r.entityType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListentitiesRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *ListEntitiesRequest
	xScioActas *string
}

// List people request
func (r ApiListentitiesRequest) Payload(payload ListEntitiesRequest) ApiListentitiesRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiListentitiesRequest) XScioActas(xScioActas string) ApiListentitiesRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiListentitiesRequest) Execute() (*ListEntitiesResponse, *http.Response, error) {
	return r.ApiService.ListentitiesExecute(r)
}

/*
Listentities List entities

List some set of details for all entities that fit the given criteria and return in the requested order. Does not support negation in filters, assumes relation type EQUALS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListentitiesRequest
*/
func (a *EntitiesAPIService) Listentities(ctx context.Context) ApiListentitiesRequest {
	return ApiListentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListEntitiesResponse
func (a *EntitiesAPIService) ListentitiesExecute(r ApiListentitiesRequest) (*ListEntitiesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListEntitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Listentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listentities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPeopleRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *PeopleRequest
	xScioActas *string
}

// People request
func (r ApiPeopleRequest) Payload(payload PeopleRequest) ApiPeopleRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiPeopleRequest) XScioActas(xScioActas string) ApiPeopleRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiPeopleRequest) Execute() (*PeopleResponse, *http.Response, error) {
	return r.ApiService.PeopleExecute(r)
}

/*
People Read people

Read people details for the given IDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPeopleRequest
*/
func (a *EntitiesAPIService) People(ctx context.Context) ApiPeopleRequest {
	return ApiPeopleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PeopleResponse
func (a *EntitiesAPIService) PeopleExecute(r ApiPeopleRequest) (*PeopleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeopleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.People")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/people"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsRequest struct {
	ctx context.Context
	ApiService *EntitiesAPIService
	payload *TeamsRequest
	xScioActas *string
}

// Teams request
func (r ApiTeamsRequest) Payload(payload TeamsRequest) ApiTeamsRequest {
	r.payload = &payload
	return r
}

// Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
func (r ApiTeamsRequest) XScioActas(xScioActas string) ApiTeamsRequest {
	r.xScioActas = &xScioActas
	return r
}

func (r ApiTeamsRequest) Execute() (*TeamsResponse, *http.Response, error) {
	return r.ApiService.TeamsExecute(r)
}

/*
Teams Read teams

Read the details of the teams with the given IDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTeamsRequest
*/
func (a *EntitiesAPIService) Teams(ctx context.Context) ApiTeamsRequest {
	return ApiTeamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TeamsResponse
func (a *EntitiesAPIService) TeamsExecute(r ApiTeamsRequest) (*TeamsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitiesAPIService.Teams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xScioActas != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Scio-Actas", r.xScioActas, "simple", "")
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
